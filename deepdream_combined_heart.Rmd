---
title: "DeepDream - Subject 2 Physiological Analysis"
author:    |
    | Colin Ayres  
    | c.ayres@student.uw.edu.pl
date: "January 2025"
output: html_document
chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Import Packages

```{r warning=FALSE, message=FALSE}
# Load necessary packages
library(tidyverse)
library(here)
library(ggplot2)
library(zoo)
library(dplyr)
library(patchwork)
library(mgcv)
library(ggpubr)
library(rstatix)

# Set working directory
mds_dir <- here::here()

```

## Defining Functions to Clean & Combine Data

```{r}
# Remove rows for which Heart Rate is 0
remove_zero_heart_rate <- function(data) {
  data %>% 
    filter(`Heart Rate` != 0)
}

# Add Time column (1000 rows = 1 second)
add_time_column <- function(data) {
  data %>%
    group_by(Id) %>%
    mutate(Time = (row_number() - 1) / 1000) %>%  # Convert row number to seconds
    ungroup()
}

# Change 4 and 8 events which are repeated to 0 (i.e. If event column has 4, 4, 4 -> 4, 0, 0)
clean_repeated_events <- function(data) {
  data %>%
    group_by(Id) %>%
    mutate(
    arrange(Id, Time) %>%  # Ensure chronological order
      # Track time differences and event changes
      time_diff = Time - lag(Time, default = -Inf),
      event_changed = EVENT != lag(EVENT, default = first(EVENT)),
      
      # Identify new clusters of 4/8
      cluster = cumsum(
        (EVENT %in% c(4, 8) & (time_diff > 0.5 | event_changed)) |
          !(EVENT %in% c(4, 8))
      )
    ) %>%
    group_by(Id, cluster) %>%
    mutate(
      # Replace repeats with 0 within each cluster
      EVENT = ifelse(
        EVENT %in% c(4, 8) & row_number() > 1,
        0,
        EVENT
      )
    ) %>%
    ungroup() %>%
    select(-time_diff, -event_changed, -cluster)  # Remove helper columns
}

clean_consecutive_rr <- function(data) {
  data %>%
    group_by(Id) %>%
    arrange(Time) %>%
    mutate(
      `Clean R-R` = if_else(
        row_number() == 1 | `ECG R-R` != lag(`ECG R-R`),
        `ECG R-R`,
        NA_real_
      )
    ) %>%
    ungroup()
}
```

## Load and Process All Subject Data

```{r warning=FALSE, message=FALSE}
# Import data
import_subjects_exp <- function(data_dir = "C:\\Users\\CAyre\\Documents\\Coding\\deepdream-analysis\\pre-study\\ECG\\ACQ") {
  # Get list of all subject files (e.g., ID01_baseline.csv, ID02_baseline.csv)
  file_list <- list.files(
    path = here(data_dir),
    pattern = "\\d+_experiment\\.csv",
    full.names = TRUE
  )

  # Read and combine all files
  data <- map_df(file_list, ~ {
    read_delim(.x, 
              delim = ";",
              col_types = cols(.default = col_character()),
              show_col_types = FALSE) %>%
      mutate(Id = as.integer(str_extract(basename(.x), "\\d+"))) %>%  # Extract ID
      type_convert()  # Automatically convert columns to appropriate types
  })

  # Arrange by subject ID
  data <- data %>% arrange(Id)

  return(data)
}

import_subjects_base <- function(data_dir = "C:\\Users\\CAyre\\Documents\\Coding\\deepdream-analysis\\pre-study\\ECG\\ACQ") {
  # Get list of all subject files (e.g., ID01_baseline.csv, ID02_baseline.csv)
  file_list <- list.files(
    path = here(data_dir),
    pattern = "ID\\d+_baseline\\.csv",
    full.names = TRUE
  )

  # Read and combine all files
  data <- map_df(file_list, ~ {
    read_delim(.x, 
              delim = ";",
              col_types = cols(.default = col_character()),
              show_col_types = FALSE) %>%
      mutate(Id = as.integer(str_extract(basename(.x), "\\d+"))) %>%  # Extract ID
      type_convert()  # Automatically convert columns to appropriate types
  })

  # Arrange by subject ID
  data <- data %>% arrange(Id)

  return(data)
}

process_all_subjects <- function(raw_data) {
  # Clean column names
  raw_data <- raw_data %>%
    #rename_all(~str_trim(.) %>% make.names()) %>%  # Force valid column names
    rename(Id = matches("^id$", ignore.case = TRUE)) %>%  # Explicitly rename ID column
    mutate(Id = as.integer(Id))
  
  # Verify Id column exists
  if (!"Id" %in% colnames(raw_data)) {
    stop("Id column still missing after renaming. Columns found: ",
         paste(colnames(raw_data), collapse = ", "))
  }
  
  # Process using split-apply-combine
  raw_data %>%
    split(.$Id) %>%  # Base R splitting by Id
    map_dfr(~ {
      .x %>%
        add_time_column() %>%
        remove_zero_heart_rate() %>%
        clean_repeated_events() %>%
        mutate(Id = first(Id))  # Explicitly maintain Id column
    }) %>%
    arrange(Id)
}


# Execution
data_exp <- import_subjects_exp()
data_base <- import_subjects_base()

data_exp_processed <- process_all_subjects(data_exp)
data_base_processed <- process_all_subjects(data_base)
data_exp_processed <- clean_consecutive_rr(data_exp_processed)
data_base_processed <- clean_consecutive_rr(data_base_processed)
```

## Investigating Events

```{r}
plot_event_by_frame <- function(subject_id, data = data_exp_processed) {
  # Filter data for the given Id and remove EVENT = 0
  subject_data <- data %>% 
    filter(Id == subject_id, EVENT != 0)
  
  # Create the plot
  ggplot(subject_data, aes(x = seq_along(EVENT), y = EVENT)) +
    geom_point(color = "red", size = 1, alpha = 0.7) +  # Add points
    labs(
      title = paste("EVENT by Frame for Id =", subject_id),
      x = "Frame (Index)",
      y = "EVENT"
    ) +
    theme_minimal()
}

# Execution
map(1:14, plot_event_by_frame)  # Loop through Ids 1-14

```

## Looking Between Events 4 and 8 for Experimental Data

### There are four sections of data per subject that occur between an event 4 and event 8 marker. Ensure there are no extraneous 4 events before proceeding with analysis

```{r}
# In the experimental data, Subject 2, there is a random event 4 at the start of the data which does not correlate to an event 8 (the next event 8 happens ~1000 seconds later). I'm filtering this out.
data_exp_processed <- data_exp_processed %>%
  mutate(
    EVENT = if_else(
      Id == 2 & Time == 1.531,  # Match time with tolerance for precision
      0,  # Replace EVENT with 0
      EVENT  # Keep original value otherwise
    )
  )

# Select only points between events 4 and 8
filter_between_events <- function(data, start_event = 4, end_event = 8) {
  data %>%
    group_by(Id) %>%
    mutate(
      start_flag = EVENT == start_event,  # Mark start points
      end_flag = EVENT == end_event       # Mark end points
    ) %>%
    mutate(
      section_id = cumsum(start_flag),  # Track sections where EVENT == 4 starts
      valid_section = section_id > lag(cumsum(end_flag), default = 0)  # Ensure pairing
    ) %>%
    filter(valid_section) %>%
    select(-start_flag, -end_flag, -valid_section) %>%
    ungroup()
}

# Filter out points between events 4 and 8
filtered_exp <- filter_between_events(data_exp_processed)


# Calculating Mean Heart Rate and Heart Rate Variability in each section (between Event = 4 and Event = 8) for each subject
results <- filtered_exp %>%
  filter(Id %in% 1:14, section_id %in% 1:4) %>%
  group_by(Id, section_id) %>%
  arrange(Time) %>%
  summarise(
    mean_heart_rate = mean(`Heart Rate`, na.rm = TRUE),
    
    # Improved HRV calculation
    heart_rate_variability = {
      clean_rr <- na.omit(`Clean R-R`)
      if (length(clean_rr) >= 2) {
        sqrt(mean(diff(clean_rr)^2))  # RMSSD from consecutive non-NA values
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    mean_heart_rate = ifelse(is.nan(mean_heart_rate), NA, mean_heart_rate)
  )
# View results sorted by Id and section
results %>% arrange(Id, section_id)


# Uncomment below to see the 4 & 8 events picked out for a given subject Id
#data_event <- data_exp_processed %>%
#  filter(Id == 2 & EVENT %in% c(4, 8)) 
#data_event

```

## Paired T-Test for Mean Heart Rate
```{r}
run_all_paired_ttests <- function(data) {
  # Check required columns exist
  required_cols <- c("Id", "section_id", "mean_heart_rate", "heart_rate_variability")
  if (!all(required_cols %in% colnames(data))) {
    stop("Missing required columns. Needed: ", paste(required_cols, collapse = ", "))
  }
  
  # Create all possible section pairs
  sections <- sort(unique(data$section_id))
  pairs <- as.data.frame(t(combn(sections, 2))) %>%
    setNames(c("section1", "section2"))
  
  # Process both metrics
  purrr::map_df(c("mean_heart_rate", "heart_rate_variability"), function(metric) {
    purrr::map_df(1:nrow(pairs), function(i) {
      pair <- pairs[i, ]
      
      # Prepare paired data for current metric
      paired_data <- data %>%
        filter(section_id %in% c(pair$section1, pair$section2)) %>%
        pivot_wider(
          id_cols = Id,
          names_from = section_id,
          values_from = all_of(metric),
          names_prefix = "section_"
        ) %>%
        na.omit()
      
      # Skip if insufficient data
      if (nrow(paired_data) < 2) {
        return(tibble(
          metric = metric,
          comparison = paste(pair$section1, "vs", pair$section2),
          message = "Insufficient data (n < 2)"
        ))
      }
      
      # Perform t-test
      t.test(
        paired_data[[paste0("section_", pair$section1)]],
        paired_data[[paste0("section_", pair$section2)]],
        paired = TRUE
      ) %>%
        broom::tidy() %>%
        mutate(
          metric = metric,
          comparison = paste(pair$section1, "vs", pair$section2),
          n_pairs = nrow(paired_data),
          .before = 1
        )
    })
  })
}

# Execute
ttest_all_results <- run_all_paired_ttests(results)
print(ttest_all_results)

```
## Plotting Paired T-test Results

```{r}
plot_individual_paired_comparisons <- function(data, ttest_results, metric = "mean_heart_rate") {
  # Filter results for specified metric
  metric_results <- ttest_results %>%
    filter(metric == !!metric) %>%
    mutate(
      section1 = as.numeric(sub(" vs.*", "", comparison)),
      section2 = as.numeric(sub(".*vs ", "", comparison))
    )
  
  # Create list of individual plots
  plots <- map(1:nrow(metric_results), function(i) {
    pair <- metric_results[i, ]
    
    # Prepare paired data
    pair_data <- data %>%
      filter(section_id %in% c(pair$section1, pair$section2)) %>%
      select(Id, section_id, value = all_of(metric)) %>%
      pivot_wider(
        names_from = section_id,
        values_from = value,
        names_prefix = "Section "
      ) %>%
      na.omit()
    
    # Convert to long format for plotting
    plot_data <- pair_data %>%
      pivot_longer(
        cols = -Id,
        names_to = "section",
        values_to = "value"
      ) %>%
      mutate(section = factor(sub("Section ", "", section)))
    
    # Create plot
    ggplot(plot_data, aes(x = section, y = value)) +
      geom_boxplot(aes(fill = section), width = 0.3, outlier.shape = NA, alpha = 0.8) +
      geom_point(color = "gray40", size = 2.5, alpha = 0.7) +
      geom_line(aes(group = Id), color = "gray60", alpha = 0.5) +
      scale_fill_brewer(palette = "Set2") +  # ColorBrewer qualitative palette
      labs(
        title = paste("Comparison:", pair$comparison),
        subtitle = paste0("Paired t-test: p = ", round(pair$p.value, 3)),
        x = "Section",
        y = ifelse(metric == "mean_heart_rate",
                   "Mean Heart Rate (bpm)", 
                   "Heart Rate Variability (RMSSD)"),
        fill = "Section"
      ) +
      theme_minimal(base_size = 14) +
      theme(
        legend.position = "right",
        panel.grid.major.x = element_blank(),
        plot.title = element_text(face = "bold"),
        plot.subtitle = element_text(color = "grey40")
      )
  })
  
  # Name plots by comparison
  names(plots) <- metric_results$comparison
  return(plots)
}

# Generate individual plots for mean heart rate
meanhr_plots <- plot_individual_paired_comparisons(
  data = results,
  ttest_results = ttest_all_results,
  metric = "mean_heart_rate"
)

# Generate individual plots for heart rate variability
hrv_plots <- plot_individual_paired_comparisons(
  data = results,
  ttest_results = ttest_all_results,
  metric = "heart_rate_variability"
)

# Access individual plots
#hrv_plots[["1 vs 2"]]
#hrv_plots[["3 vs 4"]]

# Print all plots
walk(names(meanhr_plots), ~print(meanhr_plots[[.x]]))
walk(names(hrv_plots), ~print(hrv_plots[[.x]]))

```
