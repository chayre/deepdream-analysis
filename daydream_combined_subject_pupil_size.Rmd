---
title: "DeepDream - Subject 2 Physiological Analysis"
author:    |
    | Colin Ayres  
    | c.ayres@student.uw.edu.pl
date: "January 2025"
output: html_document
chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Import Packages

```{r warning=FALSE, message=FALSE}
# Load necessary packages
library(tidyverse)
library(here)
library(ggplot2)
library(zoo)
library(dplyr)
library(patchwork)
library(mgcv)
library(ggpubr)
library(rstatix)

# Set working directory
mds_dir <- here::here()

```

## Defining Functions to Clean & Combine Data

```{r}
# Splitting Vectors into Directional Components
split_eye_direction <- function(data) {
  data %>%
    mutate(
      # Remove parentheses and split into components
      values = strsplit(gsub("[()]", "", CombinedEyeDirection), ","),
      # Extract numeric values for each dimension
      CombinedEyeDirectionX = sapply(values, function(x) as.numeric(x[1])),
      CombinedEyeDirectionY = sapply(values, function(x) as.numeric(x[2])),
      CombinedEyeDirectionZ = sapply(values, function(x) as.numeric(x[3])),
      # Remove temporary values column
      .keep = "unused"
    )
}

# While blinking, pupil values are recorded as negative. I replace negative values with interpolated values below. For example, (5, -3, -2, -4, 9) will become (5, 6, 7, 8, 9).
# Interpolate blinking values
interpolate_blinking <- function(data) {
  data %>%
    # Replace invalid values with NA
    mutate(
      LeftEyePupilSize = ifelse(LeftEyePupilSize < 0, NA, LeftEyePupilSize),
      RightEyePupilSize = ifelse(RightEyePupilSize < 0, NA, RightEyePupilSize),
      CombinedEyeDirectionX = ifelse(CombinedEyeDirectionX < -0.98, NA, CombinedEyeDirectionX),
      CombinedEyeDirectionY = ifelse(CombinedEyeDirectionY < -0.98, NA, CombinedEyeDirectionY),
      CombinedEyeDirectionZ = ifelse(CombinedEyeDirectionZ < -0.98, NA, CombinedEyeDirectionZ)
    ) %>%
    # Linear interpolation for missing values
    mutate(
      across(c(LeftEyePupilSize, RightEyePupilSize, 
               CombinedEyeDirectionX, CombinedEyeDirectionY, CombinedEyeDirectionZ),
             ~ zoo::na.approx(., na.rm = FALSE))
    ) %>%
    # Fill leading/trailing NAs using last observation carried forward/backward
    mutate(
      LeftEyePupilSize = zoo::na.locf(zoo::na.locf(LeftEyePupilSize, na.rm = FALSE, fromLast = TRUE), na.rm = FALSE),
      RightEyePupilSize = zoo::na.locf(zoo::na.locf(RightEyePupilSize, na.rm = FALSE, fromLast = TRUE), na.rm = FALSE),
      CombinedEyeDirectionX = zoo::na.locf(zoo::na.locf(CombinedEyeDirectionX, na.rm = FALSE, fromLast = TRUE), na.rm = FALSE),
      CombinedEyeDirectionY = zoo::na.locf(zoo::na.locf(CombinedEyeDirectionY, na.rm = FALSE, fromLast = TRUE), na.rm = FALSE),
      CombinedEyeDirectionZ = zoo::na.locf(zoo::na.locf(CombinedEyeDirectionZ, na.rm = FALSE, fromLast = TRUE), na.rm = FALSE)
    )
}

# Getting rid of "Countdown" (It takes 2 seconds and only appears in one of the conditions, messes up legend)
# Also getting rid of values for which Luminosity = 0
clean_phase_luminosity <- function(data) {
  # Perform cleaning operations
  data %>%
    mutate(Phase = ifelse(Phase == "Countdown", "BeforeRecording", Phase)) %>%
    filter(Luminosity != 0)
}

```

## Load and Process All Subject Data

```{r warning=FALSE, message=FALSE}
# Import data
import_subjects <- function(data_dir = "pre-study") {
  # Get list of all device data files
  file_list <- list.files(
    path = here(data_dir),
    pattern = "\\d+_DeviceData\\.csv",
    full.names = TRUE
  )
  
  # Read and combine files with semicolon separation
  map_df(file_list, ~ {
    read_delim(.x, 
              delim = ";",
              col_types = cols(.default = col_character()),
              show_col_types = FALSE) %>% 
      type_convert()  # Automatically convert columns to appropriate types
  }) %>%
    arrange(Id)  # Proper numeric sorting
}


# Process with subject isolation
process_all_subjects <- function(raw_data) {
  raw_data %>%
    group_by(Id) %>%
    group_modify(~ {
      .x %>%
        clean_phase_luminosity() %>%
        split_eye_direction() %>%
        interpolate_blinking()
    }) %>%
    ungroup() %>%
    arrange(Id, ExperimentSecond)
}

# Import/process data
processed_device_combined <- import_subjects() %>% process_all_subjects()

```


## Plotting Functions

```{r warning=FALSE, message=FALSE}
# Add normalized pupil size to the data, look at residuals
normalize_pupil_size <- function(data, model) {
  data <- data %>%
    mutate(
      AvgPupilSize = (LeftEyePupilSize + RightEyePupilSize) / 2,
      PredictedPupilSize = predict(model, newdata = data),
      ResidualPupilSize = AvgPupilSize - PredictedPupilSize
    )
  return(data)
}

# Normalized pupil size plotting
create_normalized_pupil_plot <- function(data, title, y_limits, luminosity_factor) {
  ggplot(data, aes(x = ExperimentSecond - ExperimentSecond[1])) +
      geom_smooth(aes(y = round(AvgPupilSize, 3), color = "Avg. Pupil Size"), se = FALSE, method = "loess", span = 0.012) +
    geom_line(aes(y = Luminosity * luminosity_factor, color = "Luminosity")) +
geom_smooth(aes(y = ResidualPupilSize, color = "Residual Pupil Size"), se = FALSE, method = "loess", span = 0.012) +
    scale_y_continuous(
      name = "Pupil Size (mm)",
      limits = y_limits,
      sec.axis = sec_axis(~ . / luminosity_factor, name = "Luminosity")
    ) +
    theme_minimal() +
    labs(
      title = title,
      x = "Time (seconds)",
      y = "Pupil Size (mm)",
      color = "Legend"
    ) +
    scale_color_manual(
      values = c(
        "Avg. Pupil Size" = "black",
        "Luminosity" = adjustcolor("green", alpha.f = 0.75),
        "Residual Pupil Size" = "blue"
      ),
      breaks = c("Avg. Pupil Size", "Luminosity", "Residual Pupil Size")
    )
}

# All data plotting
create_faceted_pupil_plots <- function(data, title, all_plot_y_limits, ncol = 5) {
  plot_data <- data %>%
    group_by(Id) %>%
    mutate(
      TimeElapsed = ExperimentSecond - min(ExperimentSecond),  # Relative time per subject
      AvgPupilSize = (LeftEyePupilSize + RightEyePupilSize) / 2
    ) %>%
    ungroup()
  
  ggplot(plot_data, aes(x = TimeElapsed, y = AvgPupilSize)) +
    geom_smooth(method = "loess", span = 0.015, se = FALSE, color = "#2c7bb6") +
    geom_point(size = 0.5, alpha = 0.2, color = "#636363") + 
    facet_wrap(~ Id, ncol = ncol, drop = FALSE) +
    theme_minimal(base_size = 12) +
    labs(
      title = title,
      x = "Time",
      y = "Average Pupil Size (mm)"
    ) +
    scale_y_continuous(
      limits = all_plot_y_limits,
      breaks = seq(2, 5, by = 0.5)
    ) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
      strip.background = element_rect(fill = "#f0f0f0"),
      strip.text = element_text(face = "bold", size = 10),
      panel.spacing = unit(1.2, "lines"),
      axis.text.x = element_blank() 
    )
}

```

## Modelling Pupil Size vs. Luminosity

```{r warning=FALSE, message=FALSE}
# Define common variables
common_y_limits <- c(-2, 5)  # Adjust based on your data
all_plot_y_limits <- c(2, 5)
luminosity_factor <- 14     # Scaling factor for Luminosity
id <- 9

# Filter data to only include experiment
filtered_data <- processed_device_combined %>%
  filter(
    VideoMode %in% c("Normal", "Hallucinations") &
    Phase == "Video"
  )

# Adding InverseLuminosity Column
filtered_data <- filtered_data %>%
  mutate(InverseLuminosity = 1 / Luminosity)

# Non-linear(generalized additive) model
model_gam <- gam((LeftEyePupilSize + RightEyePupilSize) / 2 ~ s(InverseLuminosity, k = 10), data = filtered_data)
data_gam <-normalize_pupil_size(filtered_data, model_gam)
data_gam <- data_gam %>% mutate(Id = factor(Id))
data_gam %>% filter(!is.na(Id)) %>% count()

# Create plots with residuals from non-linear (generalized additive) model
plot1 <- create_normalized_pupil_plot(
  data_gam %>% 
    filter(data_gam$Id == id, data_gam$VideoMode == "Normal", data_gam$VideoName == "Main_Mono_Normal_HighLayerStrong", data_gam$Phase == "Video"), "Normal Mono", common_y_limits, luminosity_factor)
plot2 <- create_normalized_pupil_plot(
  data_gam %>% 
    filter(data_gam$Id == id, data_gam$VideoMode == "Normal", data_gam$VideoName == "Main_Stereo_Normal_HighLayerStrong", data_gam$Phase == "Video"), "Normal Stereo", common_y_limits, luminosity_factor)
plot3 <- create_normalized_pupil_plot(
  data_gam %>% 
    filter(data_gam$Id == id, data_gam$VideoMode == "Hallucinations", data_gam$VideoName == "Main_Mono_Hallucinations_HighLayerStrong", data_gam$Phase == "Video"), "Hallucination Mono", common_y_limits, luminosity_factor)
plot4 <- create_normalized_pupil_plot(
  data_gam %>% 
    filter(data_gam$Id == id, data_gam$VideoMode == "Hallucinations", data_gam$VideoName == "Main_Stereo_Hallucinations_HighLayerStrong", data_gam$Phase == "Video"), "Hallucination Stereo", common_y_limits, luminosity_factor)

# Combine all plots into a 2x2 layout and display
p <- (plot1 + plot2) / (plot3 + plot4) +
  plot_layout(guides = "collect") + # Collect the legends into one
  plot_annotation(sprintf("Subject %s (Pre-Study) Pupil Size Normalized by Luminosity, Generalized Additive Model", id)) # Add a supertitle

print(p)
print(plot1)
print(plot2)
print(plot3)
print(plot4)

summary(model_gam)

# Create plot from all subjects
plotcombined1 <- create_faceted_pupil_plots(
  data_gam %>% 
    filter(data_gam$VideoMode == "Normal", data_gam$VideoName == "Main_Mono_Normal_HighLayerStrong", data_gam$Phase == "Video"), "Normal Mono (Pre-Study)", all_plot_y_limits)
plotcombined2 <- create_faceted_pupil_plots(
data_gam %>%
filter(data_gam$VideoMode == "Normal", data_gam$VideoName == "Main_Stereo_Normal_HighLayerStrong", data_gam$Phase == "Video"), "Normal Stereo (Pre-Study)", all_plot_y_limits)
plotcombined3 <- create_faceted_pupil_plots(
data_gam %>%
filter(data_gam$VideoMode == "Hallucinations", data_gam$VideoName == "Main_Mono_Hallucinations_HighLayerStrong", data_gam$Phase == "Video"), "Hallucination Mono (Pre-Study)", all_plot_y_limits)
plotcombined4 <- create_faceted_pupil_plots(
data_gam %>%
filter(data_gam$VideoMode == "Hallucinations", data_gam$VideoName == "Main_Stereo_Hallucinations_HighLayerStrong", data_gam$Phase == "Video"), "Hallucination Stereo (Pre-Study)", all_plot_y_limits)

print(plotcombined1)
print(plotcombined2)
print(plotcombined3)
print(plotcombined4)

```

## Statistical Tests for Pupil Data

```{r warning=FALSE, message=FALSE}

# Create summary data for statistical testing
condition_data <- data_gam %>%
  filter(Phase == "Video") %>%
  mutate(
    Condition = case_when(
      VideoName == "Main_Mono_Normal_HighLayerStrong" ~ "Normal_Mono",
      VideoName == "Main_Mono_Hallucinations_HighLayerStrong" ~ "Hallucination_Mono",
      VideoName == "Main_Stereo_Normal_HighLayerStrong" ~ "Normal_Stereo",
      VideoName == "Main_Stereo_Hallucinations_HighLayerStrong" ~ "Hallucination_Stereo",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(Condition)) %>%
  group_by(Id, Condition) %>%
  summarize(
    AvgPupilSize = mean((LeftEyePupilSize + RightEyePupilSize)/2, na.rm = TRUE),
    ResidualPupilSize = mean(ResidualPupilSize, na.rm = TRUE),
    .groups = "drop"
  )

# Prepare paired comparisons
comparisons <- list(
  c("Normal_Mono", "Hallucination_Mono"),
  c("Normal_Stereo", "Hallucination_Stereo")
)

# Perform paired t-tests with confidence intervals
paired_t_avgpupil <- condition_data %>%
  pairwise_t_test(
    AvgPupilSize ~ Condition,
    paired = TRUE,
    comparisons = comparisons,
    detailed = TRUE,  # This includes confidence intervals
    p.adjust.method = "none"
  )

# Perform paired t-tests with confidence intervals
paired_t_residual <- condition_data %>%
  pairwise_t_test(
    ResidualPupilSize ~ Condition,
    paired = TRUE,
    comparisons = comparisons,
    detailed = TRUE, 
    p.adjust.method = "none"
  )

# Print formatted results
print(paired_t_avgpupil)
print(paired_t_residual)

# Visualize results
ggplot(condition_data, aes(x = Condition, y = AvgPupilSize)) +
  geom_boxplot(width = 0.4, outlier.shape = NA) +
  geom_line(aes(group = Id), color = "gray", alpha = 0.4) +
  geom_point(aes(color = Condition), size = 2, alpha = 0.8) +
  stat_pvalue_manual(paired_t_avgpupil, label = "p = {p.adj}", 
                     y.position = c(4.6, 4.6)) +
  scale_x_discrete(
    limits = c("Normal_Mono", "Hallucination_Mono", 
               "Normal_Stereo", "Hallucination_Stereo") 
  ) +
  labs(title = "Mean Pupil Size Comparison Between Conditions (Paired t-test)",
       y = "Mean Pupil Size Across Video Mode",
       x = "Condition") +
  theme_minimal() +
  theme(legend.position = "none")

# Visualize results
ggplot(condition_data, aes(x = Condition, y = ResidualPupilSize)) +
  geom_boxplot(width = 0.4, outlier.shape = NA) +
  geom_line(aes(group = Id), color = "gray", alpha = 0.4) +
  geom_point(aes(color = Condition), size = 2, alpha = 0.8) +
  stat_pvalue_manual(paired_t_residual, label = "p = {p.adj}", 
                     y.position = c(1.1, 1.1)) +
  scale_x_discrete(
    limits = c("Normal_Mono", "Hallucination_Mono", 
               "Normal_Stereo", "Hallucination_Stereo") 
  ) +
  labs(title = "Mean Residual Pupil Size Comparison Between Conditions (Paired t-test)",
       y = "Mean Residual Pupil Size Across Video Mode ",
       x = "Condition") +
  theme_minimal() +
  theme(legend.position = "none")

```

## Defining Function

## Analyzing Gaze Data (Entire Sample)

```{r warning=FALSE, message=FALSE}
# Helper function to parse a string like "(-0.001, 175.308, 359.115)" into a numeric vector.
parse_vector_string <- function(vec_string) {
  # Remove parentheses
  clean_string <- gsub("[()]", "", vec_string)
  # Split by comma and optional spaces
  parts <- strsplit(clean_string, ",\\s*")[[1]]
  # Convert each part to numeric
  as.numeric(parts)
}

# Function to convert Euler angles (roll, pitch, yaw) to a rotation matrix.
# Assumes angles are in radians and the rotation order is: 
# first rotate about x (roll), then about y (pitch), then about z (yaw),
# resulting in R = R_z(yaw) %*% R_y(pitch) %*% R_x(roll).
euler_to_matrix <- function(euler) {
  # Unpack Euler angles
  roll  <- euler[1] * pi / 180  # rotation about x-axis in radians
  pitch <- euler[2] * pi / 180  # rotation about y-axis in radians
  yaw   <- euler[3] * pi / 180  # rotation about z-axis in radians
  
  # Rotation matrix about the x-axis
  R_x <- matrix(c(
    1,         0,          0,
    0, cos(roll), -sin(roll),
    0, sin(roll),  cos(roll)
  ), nrow = 3, byrow = TRUE)
  
  # Rotation matrix about the y-axis
  R_y <- matrix(c(
    cos(pitch), 0, sin(pitch),
    0,          1,         0,
    -sin(pitch), 0, cos(pitch)
  ), nrow = 3, byrow = TRUE)
  
  # Rotation matrix about the z-axis
  R_z <- matrix(c(
    cos(yaw), -sin(yaw), 0,
    sin(yaw),  cos(yaw), 0,
    0,              0,   1
  ), nrow = 3, byrow = TRUE)
  
  # Combine rotations: first roll, then pitch, then yaw.
  # The resulting matrix rotates a vector from the headset's local coordinate system
  # to world space.
  rot_matrix <- R_z %*% R_y %*% R_x
  return(rot_matrix)
}

# Function to calculate world gaze vectors using Euler angles for device rotation.
# Assumes that 'data' is a data frame where:
# - data[,"DeviceRotation"] contains a 3-element vector (roll, pitch, yaw) in radians,
# - data[,"values"] contains the combined eye direction as a 3-element vector.
calculate_world_gaze_vectors <- function(data) {
  n_samples <- nrow(data)
  world_vectors <- matrix(0, nrow = n_samples, ncol = 3)
  
  for(i in 1:n_samples) {
    # Extract DeviceRotation Euler angles (roll, pitch, yaw)
    # Ensure the rotation vector is numeric and of length 3.
    # Extract DeviceRotation string and parse it into a numeric vector (roll, pitch, yaw in degrees)
    rotation_string <- as.character(data[i, "DeviceRotation"])
    rotation <- parse_vector_string(rotation_string)
    rot_matrix <- euler_to_matrix(rotation)
   
    # Extract CombinedEyeDirection (x, y, z)
    eye_direction <- as.numeric(trimws(unlist(data[i, "values"])))

    #print(rotation_string <- as.character(data_gam[1, "DeviceRotation"]))
    #print(euler_to_matrix(parse_vector_string(rotation_string)))
    #print(as.numeric(trimws(unlist(data_gam[1, "values"]))))
    
    # Transform the eye direction vector from the headset's local space to world space
    world_vectors[i, ] <- rot_matrix %*% eye_direction
  }
  
  return(world_vectors)
}

# Calculate angle between vectors
calculate_angular_diff <- function(v1, v2) {
  v1_norm <- v1 / sqrt(sum(v1^2))
  v2_norm <- v2 / sqrt(sum(v2^2))
  
  dot_prod <- sum(v1_norm * v2_norm)
  dot_prod <- max(min(dot_prod, 1), -1)
  angle_rad <- acos(dot_prod)
  
  return(angle_rad * 180 / pi)
}

# Calculate compensated gaze stability
calculate_gaze_stability <- function(data, window_size = 30) {
  world_vectors <- calculate_world_gaze_vectors(data)
  
  n_samples <- nrow(world_vectors)
  angular_differences <- numeric(n_samples - 1)
  
  # Calculate angular differences between consecutive frames
  for(i in 2:n_samples) {
    angular_differences[i-1] <- calculate_angular_diff(
      world_vectors[i,],
      world_vectors[i-1,]
    )
  }
  
  # Calculate rolling stability scores
  n_windows <- length(angular_differences) - window_size + 1
  stability_scores <- numeric(n_windows)
  
  for(i in 1:n_windows) {
    window <- angular_differences[i:(i + window_size - 1)]
    stability_scores[i] <- mean(window)
  }
  
  list(
    stability_scores = stability_scores,
    angular_differences = angular_differences
  )
}

# Detect stable fixations
detect_fixations <- function(angular_differences, max_angle = 1.0, min_duration = 10) {
  n_samples <- length(angular_differences)
  fixation_periods <- list()
  current_start <- NULL
  
  for(i in 1:n_samples) {
    if(angular_differences[i] <= max_angle) {
      if(is.null(current_start)) {
        current_start <- i
      }
    } else {
      if(!is.null(current_start)) {
        duration <- i - current_start
        if(duration >= min_duration) {
          fixation_periods[[length(fixation_periods) + 1]] <- c(current_start, i)
        }
        current_start <- NULL
      }
    }
  }
  
  # Check for fixation at end
  if(!is.null(current_start)) {
    duration <- n_samples - current_start + 1
    if(duration >= min_duration) {
      fixation_periods[[length(fixation_periods) + 1]] <- c(current_start, n_samples)
    }
  }
  
  return(fixation_periods)
}
# Calculate vergence
calculate_vergence <- function(data) {
  n_samples <- nrow(data)
  vergence_angles <- numeric(n_samples)
  
  for(i in 1:n_samples) {
    left_dir <- parse_vector_string(as.character(data[i, "LeftEyeDirection"]))
    right_dir <- parse_vector_string(as.character(data[i, "RightEyeDirection"]))
    vergence_angles[i] <- calculate_angular_diff(left_dir, right_dir)
  }
  
  return(vergence_angles)
}

# Main analysis function
analyze_eye_tracking <- function(data, window_size = 30) {
  # Calculate stability metrics
  stability_results <- calculate_gaze_stability(data, window_size)
  
  # Calculate vergence
  vergence_angles <- calculate_vergence(data)
  
  # Detect fixations
  fixation_periods <- detect_fixations(stability_results$angular_differences)
  
  # Calculate comprehensive metrics
  metrics <- list(
    # Stability metrics
    mean_stability = mean(stability_results$stability_scores),
    std_stability = sd(stability_results$stability_scores),
    max_angular_difference = max(stability_results$angular_differences),
    
    # Fixation metrics
    number_of_fixations = length(fixation_periods),
    total_fixation_time = sum(sapply(fixation_periods, function(x) x[2] - x[1])),
    fixation_periods = fixation_periods,
    
    # Eye metrics
    mean_left_openness = mean(data$LeftEyeOpeness),
    mean_right_openness = mean(data$RightEyeOpeness),
    mean_left_pupil = mean(data$LeftEyePupilSize),
    mean_right_pupil = mean(data$RightEyePupilSize),
    
    # Vergence metrics
    mean_vergence = mean(vergence_angles),
    std_vergence = sd(vergence_angles),
    
    # Raw data for plotting
    stability_scores = stability_results$stability_scores,
    angular_differences = stability_results$angular_differences,
    vergence_angles = vergence_angles
  )
  
  return(metrics)
}

# Execute Analysis
results <- analyze_eye_tracking(data_gam)

# Basic plotting function
plot_eye_tracking <- function(results) {
  # Create basic plots using base R
  par(mfrow = c(2, 2))
  
  # Stability scores over time
  plot(results$stability_scores, type = "l",
       main = "Gaze Stability Over Time",
       xlab = "Frame", ylab = "Stability Score", ylim = range(results$stability_scores, na.rm = TRUE))
  
  # Angular differences
  plot(results$angular_differences, type = "l",
       main = "Angular Differences Between Frames",
       xlab = "Frame", ylab = "Angular Difference (degrees)", ylim = range(results$angular_differences, na.rm = TRUE))
  
  # Vergence angles
  plot(results$vergence_angles, type = "l",
       main = "Vergence Angles Over Time",
       xlab = "Frame", ylab = "Vergence Angle (degrees)", ylim = range(results$angular_differences, na.rm = TRUE))
  
  # Reset plot layout
  par(mfrow = c(1, 1))
}

# Plot Results
plot_eye_tracking(results)


summary(results$stability_scores)
summary(results$angular_differences)
summary(results$vergence_angles)
#results$total_fixation_time
```

